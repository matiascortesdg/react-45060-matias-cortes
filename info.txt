
Info importante a tener en cuenta con COMPONENTES en React
__

1. Todos los componentes son funciones.
    
    Antes llamamos y ejecutabamos funciones así:
    
    const foo = () => {}
    foo();

2. Todos los componenes se escriben con la inicial en MAYUSUCLA.

    - en React - 
    const Foo = () => {}

3. Todos los componentes DEBEN RETORNAN SI O SI ALGO. No importa qué.
    
    const Foo = () => {
        return()
    }

4. Todos los componentes DEBEN RETORNAR 1 (UN) SÓLO ELEMENTO.

5. Los componentes retornan JSX

6. Todos los componentes pueden recibir PROPS({}) o enviar PROPS a otros componentes.


    
    Qué son los JSX? -> es JavaScript +  XML
    Y son una extension de JavaScript. NO es de React. Y quien se encarga, la libreria, que yo pueda tener JSX dentro y utilizar React es BABEL.

    Qué es BABEL?
    BABEL es un TRANSPILADOR de Codigo. Toma una sintaxis de un codigo y lo transforma en una sintaxis valida para el navegador. En este caso el JSX.

    Transpilador
    https://www.babeljs.io
    
    Compilador
    https://www.gulpjs.com

    ej:
    
    JSX -> <div id="contenedor"> Bienvenidos </div>

    Cómo leería el navegador mi codigo?

    react.createElement( "div", {id:"contenedor"}, 'Bienvenidos' );

    
    <> </> REACT FRAGMENTS
    ----

    Para agrupar 1 elementos agrupador y evitar errores se llama: FRAGMENTS
    Evitamos usar un div y ponemos varias etiquetas dentro de <> y no se puede ponerle clases ni estilos. Usar estrategicamente cuando necesitamos traer varios elementos.


    DEntro de la carpeta src vamos a crear nuestros componentes
    Los archivos deben comenzar con inicial en MAYUSCULA como en el codigo EJ: Header.jsx

    Dividir por componentes
    
    Ej: //Creo el componente Header.jsx arrow function, con su return y al final EXPORT DEFAUKT exportamos para importarlo desde nuestro App.js

    rafce -> Atajo para crear plantilla de (const Header = () => {return()}) de componente

    El orden del codigo es el orden que se muestra

    export default
    ----
    se importa sin llaves ejemplo (import Header from './components/Header';)

    export nombrado
    ----
    va entre llaves y puede exportar varios elementos desde un mismo componente porque se puede tener 1 solo export default por archivo y el export se coloca por delante de la const:
    (export const Header = () => {return()}))
    
    Y se importa con llaves, ejemplo, desde App quedaria, 
    (import { Header, Otro, etc... } from './components/Header';)

    + Solo puede haber 1 export default por archivo

    Si quiero reutilizar un componente ya creado lo llamo entre </>

    Los estilos son heredados y si quiero darle una clase a una etiqueta debería ser con className='navbar'> ejmeplo   <nav className='navbar'>
    Que sean heredados significa que va a darle prioridad al que está mas cercano




    PROPS
    ----

	Qué son las props y para quénos sirven?

	Puede servir para generar una logica y dividir el código. Generar una logica en el componente A y enviar esa logica al componente B para que este componente B la muestre en pantalla. De esta manera podemos modular, delegar y dividir la logica.


    También es que son reutilizables, por ejemplo, teng un componente boton y este sea dinamica y que muestre un texto y /o color diferente. segun sea el contexto.

    También se pueden pasar valores por default a traves de PROPS para evitar, por ejemplo, undefined en el return.

    esta es la forma:
        
        Foo key={value} />

    const Foo = (props) => {}
    const saludar = () => {console.log('Bienvenidos')}
    
    strings -> <Foo nombre='Eric'/>
    numbers -> <Foo number={10} />
    objetos -> <Foo persona={{id:1, nombre:"Fabian}}
    array   -> <Foo listaDeSuper={["Manzana", "Banana"]} />
    boolean -> <Foo 
    funciones -><Foo listaDeSuper={saludar} />
    componentes

    mezclados -> <Foo cuerpo={ "Eric" edad={30} otraCosa{} }/>;
    Siempre que mando una o varias PROPS me devuelve un objeto.

    Cuando conviene pasar por PROPS?
    ----

        Pasar de padres a hijos la logica el resultado de esa logica la renderiza y la muestra.

        Componentes contenedor le pasan la logica a los componentes presentacionales mediante las props, unidireccional, o sea, de padres hacia hijo.



    LAYOUT
    ---- 

    Pasar por CHILDREN

    Es una palabra reservada de React, cuando envuelvo un componente para envolver otro componente. Y toda esa informacion envuelta me llega como una prop llamada CHILDREN al componente que está envolviendo.

    Todo el codigo que pase por layout

    ICONS
    ----

    React Icons
    https://www.react-icons.github.io/react-icons/

    Google Fonts Icons
    https://www.fonts.google.com/?selected=Material+Icons:home

    
    IMG
    ----
    Link from web
        <img src="" alt="" />

    Link desde public (siempre poner la ruta correcta)
        <img src="../public/logo192.png" alt="logo" />  

    Link desde src (la importo: y luego la la llamo entre llaves.
    
        import logo from '../img/logo192.png';)

        y en el Navbar entre llaves
        <img src={logo} alt="logo" />


EVENTOS
----

Todos los eventos van en camelCase y se escriben en la propia etiqueta html ej:

	<p onClick={Funcion}>Hola!{Saludo}</p>

Si tengo que pasarle un argumento a la funcion debemos hacer una callback y quedaria algo así

	
	<p onClick={() => saludar ('React')}>Hola!{Saludo}</p>


ESTADOS
----

Nos van a permitir PERSISTIR INFORMACION a medida que el propio componente se vaya renderizando. Como sie fuera una memoria interna del componente.

 CADA VEZ UE HAYA UN CAMBIO DE ESTADO, CAMBIO DE PROP O UN EVENTO QUE DISPARE UN CAMBIO DE ESTADO O UN CAMBIO DE PROP SE VOLVERÁ A RENDERIZAR EL COMPONENTE. Y LOS HIJOS DE ESE COMPONENTE TAMBIÉN.

    Hooks
    ----

    useState
    --

    Ejemplo:
    const = [state, setState] = useState(0)

    La primera posicion es mi estado(state) y la segunda es la funcion seteadora(setState). Dentro del parentesis puedo poner un valor inicial para que mi estado no arranque en undefineduseState(0).

    LA UNICA MANERA QUE TENGO DE MODIFICAR MI ESTADO es atraves de la funcion seteadora:

        setState(state + 10)
    REACT sólo modifica el DOM cuando escucha que se emite una función seteadora.

    
    
    useEffect()
    --

    Elegir y poder Codear aue pase algo luego de una vez renderizado en pantalla lo que tenga el componente?
    
    useEffect permite ejecutar codigo luego del primer renderizado del componente (return)

        // Este 1er useEffect se volverá a renderizar cuando hya un cambio de estado o de prop o un evento que dispare un cambio de estado o cambio de prop. Hay que tener cuidado de no generar un loop de cambio de estado en este useEffect.
        //este codigo se renderizaría luego del primer renderizado del return

        //Este 2do useEffect se ejecuta luego del render y se ejecuta 1 sola vez por el array de dependencia , []); y ES IDEAL PARA LLAMADAS ASINCRONICAS, una API. Si el hijo se renderiza no afecta al padre.

        //este 3era useEffect se ejecuta luego del render y se ejecuta 1 sola y luego cada vez que cambiamos la dependencia que le indicamos entre corchetes([texto]);
        Un uso puede ser ir a buscar inforacion a una API externa.


PROMISE (asincronía)
----

Una promesa es un objeto que permite representar y seuir el ciclo de vida de una tarea/operación (funcion)

Estados posibles:
    pending => (fullfilled || rejected)

    .isFullfilled
    .is.Pending
    .isRejected

como se resuelve?
    
    const task = new Promise((resolve, reject) => {
        //tarea asíncrona usando fetch, ajax
        resolve(true)
    });
    task.then(result => {
        console.log(result);
    });



APIs
----

La mayoria de las aplicaciones suelen generar eperiencias de suaurio gracias a que se puede conectar a un conjunto de servicios de datos.
Por lo tanto necesitamos conectarnos con otros servicios y mostrarlo en nuestra aplicación.

    Modelo-cliente servidor
    -- 

    El cliente siempre es el que hace la consulta. y el servidor es el que responde y brinda la informacion.

    El servidor busca info a la base de datos. esto lo hace cliente de la base de datos.

    Client -> server -> Data Base
    Client <- server <- Data Base

    Con protocolos como https para comunicarnos con el servidor. Otro puede ser FTP, por ejemplo, para subirlo de nuestra pc a un servidor.

    SSH github de seguridad.

    El cliente inicia y solicita la informacion.
    Para esto necesitamos darle al servidor:
        1- La URL -> en el endpoint al cual yo voy a acceder.
        2- Metodo: va  a ser: get, post, edit, update, option, etc... para utilizar para trae info, enviar info, editar info, etc.

    Además, podemos brindarle al servidor la info de mi headers, body

    Enviamos la informacion en formato .json que es un formato de texto.

    Las notificaciones PUSH, sería lo contrario. El servidor inicia y elige el momento del inicio de la transferencia y la envia a un servicio. Y el servicio se la provee al cliente. Esta es la forma que las aplicaciones generen engagement.

    De no utiizar push, el Polling tendriamos pedidos de info o request hacia el servidor. 

    REQUEST VIA HTTP/s
    --
    permiten realizar una solicitud a un servidor, y nos proemiten establecer un protocolo de transferencia definido por:

     - direccion URL
     - METODOS x VERBOS: 
        
        GET -> quiero obtener -> get /pet/{petId} -> find pet by id
            un GET podría ser cacheado

        POST -> quiero crear  -> post /pet/{petId}/uplpadImage -> uploads an image
            el navegador sabe que un POST no deberia ser cacheado, ej, info de trans o tarjeta de credito.

        PUT -> quiero crear o actualizar -> put /pet update an existing pet.
        
        DELETE -> quiero elimininar -> delete /pet/{petId}/ deletes a pet.

        PATCH -> quiero alterar parcialmente

     - QUERY PARAMOS (parámetros via query o URL)

        Nos permiten incluir en la direccion informacion que se usa para especificarle al receptor parametros qpara afectuar una busqueda, son mas comunes para buscar recursos que no tengo la seguridad de que existan, ej:

            https://google.com.ar/search?q=coderhouse

            Esto se puede leer como:
                - buscar en google.com.ar 
                - utilizando https
                - el recurso search? (resultados de busqueda)
                - que contenga la palabra (q= query) 'coderhouse'
                
        URL QUERY PARAMS
        ---
            - se separa la URL de los parametros utiizando signo de ?
            - Cada parametro tendra key=value & key2=value2
            - Cada parametro se puede separar por signo &
                
                ej: https://url.com/find?type=order&id=1234


        URL PARAMS/SEGMENT
        ---
            - Son una convencion para incluir el identificador del recurso dentro de la misma url, son mas comines cuando yase conoce el recurso específico que se buscará. Ej:

                https://myapp.coder/student/1234
                se puede leer como:
                - busca en myapp.coder
                - utilizando https
                - el recurso student
                - con id 1234

                https://myapp.coder/student/1234/courses
                se puede leer como:
                - busca en myapp.coder
                - utilizando https
                - el recurso courses
                - unicamente para student 1234
                
        RECURSOS/RESTFUL (la arquitectura)
        ---
            Cuando se crea y provee un servicio basado y pensado en terminos de crecursos y se respetan las convenciones de verbo/metodo y codoigo de respuesta, estamos frente a un diseño arquitectural de tipo REST

            Si además transferimos JavaScript o XML, es conocido com AJAX.


     - HEADERS (config)

        Request -> son los que Enviamos
        Response -> son los que me devuelve

        POST /create-user http/1.1
        Host: localhost:3000
        Connection_ kepp-alive
        Content-type: application/json

     - BODY (contenido en un POST)

        { "name": "john", "age": 35 }
        Se podría enviar usuario y contraseña para un login por ej.



        Se utiliza para transferir piezas de informacion entre el cliente y el servidor




    HTTP codigo que nos devuelve la promesa cuando hacemos un fetch, axios, etc...

   Status:
        fetch, ajax, axios, nos devuleven promesas.

 Lo importante es controlar que nos devuelve esa promesa.

    erroes de codigo exlicado con gatitos
    https://http.cat/

    los 100 > info
    los 200 > info correcta
    +200 > reedireccion 
    los 400 > errores de cliente
    +500 > errores del servidor (lo peores errores)

    Una de las funcion s para traer esa rspuesta, jempl un array de productos, es .json de la respuesta.
    
    Si nos devuelve otra promesa debemos convertir ese json en un array de productos.

    CORS
    --
    Al hacer un request, nos podemos encontrar con este problema/error
    de acceso. Por ej: lo unicos que pueden hacer request son desde una determinada URL.


ROUTES
----

La facilidad con la que nuestra aplicacion permte agrgar funcionalidades y navegarlas es un factor clave en temrinos de experiencia y escalabilidad.

    PASO A PASO 

    HOME (INICIO) -> BUSQUEDA > DETALLE > CONFIRMACION > FIN


Entonces tenemos las RUTAS:

    ROUTING
    --

    INSTALACION DE ROUTER (en cada proyecto que necesite rutas)
    --

    npm install react-router-dom
    esta es la libreria para routing en el browser (NAVEGADOR)

    react-router-native 
    esta es la libreria para rounting en react-native

    En App.js
    
        //importo la libreria react-router-dom
        import {BrowserRouter,  } from 'react-router-dom'

    BrowserRouter > es el componente que que va a envolver a toda nuestra aplicacion y va a dar todas las funcionalidades que voy a poder usar con la libreria. Y así le provee a los otros componentes todas esas funcionalidades.

    Routes > importo 2da libreria
    
        import {BrowserRouter, Routes  } from 'react-router-dom'

    Routes > es el componente que va a envolver las rutas de mi aplicacion. Por lo tanto Header Nav y Footer podría no estar dentro ya que queremos que se vean siempre.

    
    Routes > importo 3era libreria
    
        import {BrowserRouter, Routes, Route  } from 'react-router-dom'

    Route > es el componente que va a envolver cada ruta (  y la etiqueta abre y cierra) y dentro lleva 2 paramtros:

        <Route path='/' element={}>
    
    path > path='/' indica cual va aser la ruta del home, la que se renderiza al iniciar la aplicacion.
  
    element > el 2do parametro es el elmento que yo quiera renderizar cuando yo esta ruta.

    LINK
    --

    Dentro de la libreria react-router-dom podemos import el componente Link
            import { Link } from 'react-router-dom'

            y donde antes utilizamos la etiqueta <a> la vamos reemplazar por la <Link to=""></Link> y el href por el to=""

    Podemos usar la etiqueta NavLink para agregarle la funcion de .active cuando se esté en esa ruta

            <NavLink to="/category/trail" className="li">Trail</NavLink>
    
Ahora para hacer la ruta hacia cada NavLnk, categorias y demas en cada Route le agregamos un parametro dinamico, en ese caso :categoryName como un parametro dinamico.   

        <Route  path="/category/:categoryName"
                element={<ItemListContainer />}
        />

Para terminar la ruta vamos a utilizar otro componente de la libreria react-router-dom llamado useParams y se importa

            import { useParams } from 'react-router-dom'

esa variable que nosotros le ponemos le nombre que queramos, en este caso, categoryName que viene despues de los : y esto la libreria lo va a tomar como un parametro dinamico. Y luego voy a poder leer esa variable en el componente
que está indicando la ruta, en este caso ItemListContainer llerlo a traves del hook useParams.


EVENTOS 
----
eventos en formularios
    onSubmit="enviarDatos{}

    inputs controlados
    --

    inputs no controlados(formulario que react no recomienda porque no puede acceder a todo)
    --
    

CONTEXT 
----

A diferencia de la props que son siempre de padre a hijo. Para evitar errores de props, o cuando son demasiados. Y ademas, siempre se vuelve tedioso pasar de un componente a otro. Esto sería como un ATAJO a un deposito donde uno puede llevar o traer algo. No importa el orden de los componente.

Podriamos tener un contexto de usuarios, de light dark mode, de carrito de compras, etc. Para pasar toda la info que tenemos desde ItemDetail a CArtWidget, al Cart oal ItemCount, creamos un nuevo "componente" de LOGICA llamado CONTEXTO y desde el CONTEXTO a donde nosotros querramos. Es una herramienta de React. Vamos a poder manejar Estados, Funciones y Variables.

    creatContext -> para crea un contexto
    useContext -> usar un contexto (es un Hook)
    Provider -> provee la info de ese contexto

        import { createContext } from 'react';
        import { products } from './products';
        import { useState } from 'react';

        const PruebaContexto = createContext ();

        y usamos el Provider para envolver componentes y sus hijos tienen acceso al contexto.

        const [ prod, setProd ] = useState(products);

        <PruebaContexto.Provider value={prod}>
            <CardContainer />
        </PruebaContexto.Provider>

    y vamos a usar useState para crear un estado y a traves de la paabra reservada value y con esta key van a tener acceso

    Para traer la info del contexto vamos a utilizar el hook useContext

        import { useContext } from 'react';
        import { PruebaContexto } from './App';

        const valor = useContext(PruebaContexto); 



TECNICAS DE RENDERING
----

Optar por disintos caminos a traves de condicionales.
True False en cualquier tipo de componentes, estilos, etc..

    Rendering condicionales
    --

    -> Sirve para aparecer y desaparecer nodos del render

    -> Estos eventos provocan dismounting y todos los efectos que ellos conlleva

    -> Se llamará efecto de desmontaje y podremos detectarlo

    -> Podemos usar los cleanup effects para detectar algún dismountung si no sabemos con certeza si ocurre

    -> a veces se producen sin intención y causan bugs o perdida no intencionada del estado, dando inestabilidad.

        Tecnicas de Rendering condicionales
        -
        1. IF CON RETURN TEMPRANO
            React renderiza el resultado 

        installation SPINNERS

        $ npm i react-spinners

        
        2. INLINE CON FRAGMENTS (usarlo en ItemCount)

        3. TERMARIOS en ItemDetail

PERFORMANCE
--
Si no modularizamos estamos ante un caso de performance y se renderiza el componente. Lo mejor es saber bien modularizar los componentes. Para esto podemos usar algunos hooks.

Esto tambien si significa que hay que saber donde aplicar donde ejecutar herramientas de performance porque puede ser contraproducente.

    Hooks
    -

    1. useEffect(() => {}, []) -> metodo que dentro tiene un callback y puede llevar o no una dependencia.
    
    2. useMemo(() => {}, []) -> memo -> para memoriza valores

        Memorizamos el componente:
                export default memo(Componente);
        y se importa
            import { memo } from 'react'
        

    3. useCallback(() => {}, []) -> memoriza funciones por eejmplo si dentro de una componente memorizamos 1 de las 3 funciones  eviatar que se rendericen las 3 con cada clic sino la que cambia.
        

            const aumentar1 = useCallback(() => {
            cambiarContador1(contador1 +1);
            }, [contador1]);
        
            const aumentar2 = useCallback(() => {
            cambiarContador2(contador2 +1);
            }, [contador2]);
        
            const aumentar3 = useCallback(() => {
            cambiarContador3(contador3 +1);
            }, [contador3]);
